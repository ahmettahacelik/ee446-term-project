\documentclass[12pt]{report}

\usepackage{graphicx}
\usepackage{float}
\usepackage{biblatex}
\usepackage[a4paper, margin=1in]{geometry}

\makeatletter
\renewcommand{\maketitle}{
\begin{center}

\pagestyle{empty}
\phantom{.}  %necessary to add space on top before the title
\vspace{0.5cm}

{\Huge \bf \@title\par}
\vspace{5cm}

{\LARGE Zülal Uludoğan, }\\[0.5cm]
{\LARGE Ahmet Taha Çelik, 2515831}

\vfill

{\Large\@date}

\end{center}
}\makeatother

\title{EE446 Term Project Report \\ Middle East Technical University}
\author{Ahmet Taha Çelik, Zülal Uludoğan}
\date{25 May 2025}

\begin{document}

\maketitle
\tableofcontents

\chapter{Introduction}

\section{Project Description}


\chapter{Datapath Module}


\chapter{Controller Module}

\paragraph{}
The controller module is responsible for generating the control signals necessary to guide the datapath during the execution of RISC-V instructions. As shown in Figure \ref{fig:controller}, the controller design follows a modular approach and includes three functional units: the \texttt{MainDecoder}, the \texttt{ALUDecoder}, and the \texttt{PCLogic} unit.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/controller_rtl.png}
    \caption{Synthesized RTL view of the controller module}
    \label{fig:controller}
\end{figure}

\paragraph{}
The \texttt{MainDecoder} interprets the 7-bit opcode from the instruction and produces the primary control signals required by the datapath, such as register file write enable, memory write enable, ALU source selection, and immediate format selection. These signals are then distributed to the corresponding components to orchestrate the processor's behavior.

\paragraph{}
The \texttt{ALUDecoder} further refines control signal generation by examining the \texttt{funct3}, \texttt{funct7}, and other opcode-specific bits to determine the specific ALU operation to perform. It outputs a 4-bit \texttt{ALUControl} signal, ensuring the correct arithmetic or logical operation is selected based on the instruction type.

\paragraph{}
The \texttt{PCLogic} unit handles program counter selection. It considers both the branching conditions and the jump instructions to compute the correct value of the \texttt{PCSrc} signal. This logic is critical for implementing both conditional and unconditional control-flow changes in the processor.

\paragraph{}
The modularity of this controller design simplifies debugging and testing. Each submodule is implemented independently and tested in isolation before integration into the main controller unit.


\chapter{UART Module}

\paragraph{}
The UART (Universal Asynchronous Receiver-Transmitter) module is responsible for facilitating serial communication between the RISC-V processor and external systems. Its implementation involved significantly more complexity than the controller module due to the nature of asynchronous communication, timing constraints, and the need to bridge two separate clock domains. Figure \ref{fig:uart} shows the synthesized RTL view of the UART subsystem.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{figures/uart_rtl.png}
    \caption{Synthesized RTL view of the UART module}
    \label{fig:uart}
\end{figure}

\section{Design Overview}

\paragraph{}
The UART module integrates both transmitting and receiving functionalities while adhering to the 9600 baud 8-N-1 protocol. Memory-mapped I/O is used to send and receive bytes via store and load instructions to addresses \texttt{0x400} and \texttt{0x404}, respectively. When a store is made to \texttt{0x400}, a byte is written to the transmitter FIFO and scheduled for transmission. When a load is performed from \texttt{0x404}, the system reads the most recent byte from the receive FIFO; if no byte is available, the value \texttt{0xFFFFFFFF} is returned.

\paragraph{}
The UART controller examines the current instruction's opcode, \texttt{funct3}, and ALU result to determine whether a UART send or receive should be triggered. This controller outputs \texttt{uart\_tx} or \texttt{uart\_rx} flags accordingly.

\section{Clock Domain Challenges and FIFO Synchronization}

\paragraph{}
One of the key challenges in designing the UART module was handling the presence of two independent clocks: a 100 MHz clock (\texttt{CLK100MHZ}) used for UART timing, and a slower user-controlled system clock (\texttt{clk}) used by the processor core and instruction sequencing. These clocks operate asynchronously, making it unsafe to directly transfer data across domains without proper synchronization.

\paragraph{}
To address this, the design uses dual-clock FIFO buffers for UART transmission and reception, each operating with distinct read and write clocks. Specifically, the \texttt{rx\_fifo} writes incoming bytes using \texttt{CLK100MHZ}, since it is fed by the UART receiver module, which samples serial input at high speed. Its read operations are driven by the processor's \texttt{clk}, as the register file reads received data at the system clock rate. Conversely, the \texttt{tx\_fifo} receives data from the processor via \texttt{clk} during store operations to address \texttt{0x400}, and its contents are transmitted by the UART transmitter at \texttt{CLK100MHZ}. 

\paragraph{}
This deliberate separation ensures safe and reliable data movement between asynchronous domains. Without this dual-clock setup, writing data from one domain and reading it from another could cause metastability or timing hazards, potentially corrupting the data. By isolating read and write logic through clock-specific ports in each FIFO, the design maintains correctness and stability throughout UART communication.


\section{UART Transmitter and Receiver}

\paragraph{}
The transmitter module initiates data transmission when a byte is enqueued into the FIFO and the line is idle. It serializes the data byte according to UART protocol and asserts the \texttt{tx\_idle} signal once transmission is complete. If the FIFO holds multiple bytes, they are transmitted sequentially without processor intervention.

\paragraph{}
The receiver module continuously samples the input \texttt{rx} line using \texttt{CLK100MHZ}. When a valid start bit is detected, it begins capturing bits until the full byte is received. A \texttt{done} flag is raised once reception is complete. The received byte is then pushed into the 16-byte FIFO buffer, ensuring that no bytes are lost if the processor is not immediately ready to read.

\section{UART Transmitter and Receiver State Machines}

\paragraph{}
Both the UART transmitter and receiver modules are implemented as finite state machines (FSMs) that operate on the 100 MHz clock and comply with the 9600 baud 8-N-1 UART protocol. Their behaviors are structured as sequential state transitions, and the FSM logic ensures the correct serialization and deserialization of data.

\subsection{Transmitter State Machine}

\paragraph{}
The transmitter FSM begins in the \texttt{IDLE} state, where it waits for the \texttt{start} signal to be asserted, indicating that a new byte is ready for transmission. Upon activation, it transitions to the \texttt{START} state and drives the transmission line low to indicate the start bit. After holding the line low for one baud period, the FSM enters the \texttt{DATA} state, during which each of the 8 data bits is shifted out sequentially, least significant bit first.

\paragraph{}
Once all data bits are transmitted, the FSM transitions to the \texttt{STOP} state. It then drives the line high for one baud period to signal the stop bit. After this, the FSM returns to the \texttt{IDLE} state, sets the \texttt{idle} flag to indicate readiness, and awaits the next start signal.

\paragraph{}
This structure ensures that every byte is framed with a start and stop bit as per UART standards, and the \texttt{idle} output allows external logic to determine when the transmitter is available for the next byte.

\subsection{Receiver State Machine}

\paragraph{}
The receiver FSM also begins in an \texttt{IDLE} state, continuously monitoring the input \texttt{rx} line. Upon detecting a falling edge (start bit), it transitions to the \texttt{START} state and waits half a baud period to sample the start bit in the middle for noise immunity.

\paragraph{}
After verifying the start bit, it transitions to the \texttt{DATA} state, where it samples 8 data bits at one baud interval each. These bits are shifted into a register, with the least significant bit arriving first.

\paragraph{}
Following the data bits, the FSM enters the \texttt{STOP} state to sample the stop bit. If the stop bit is valid (logic high), the FSM sets the \texttt{done} flag and updates the \texttt{data\_out} register with the fully received byte. It then returns to the \texttt{IDLE} state to prepare for the next frame.

\paragraph{}
This approach ensures that bytes are received reliably and with proper framing. The \texttt{done} signal is used to indicate reception completion, allowing external logic to push the received byte into a FIFO buffer or register.

\section{Peripheral Interface and Integration Strategy}

\paragraph{}
The UART module is designed to integrate seamlessly with the existing processor datapath, requiring minimal changes to the overall system architecture. It relies entirely on memory-mapped communication, interpreting store and load instructions to specific addresses as UART transmit and receive operations, respectively. This eliminates the need for additional global control signals or structural changes outside the UART module itself.

\paragraph{}
A key feature of the integration is the \texttt{ReadData\_RX} signal, which is an output of the UART module. This signal is dynamically assigned based on whether the currently executed instruction is a UART receive. If the instruction is a regular memory load, \texttt{ReadData\_RX} simply propagates the value from the data memory, making it identical to \texttt{ReadData}. However, if the instruction is a UART receive, the module substitutes the memory output with a value retrieved from the UART receive FIFO, either the latest received byte or a default fallback value if the buffer is empty.

\paragraph{}
This design allows the UART to be embedded into the system with minimal modification to the datapath. Specifically, the only change required is at the result selection stage, where the processor chooses between the ALU result and the output from memory (or UART). Since this behavior is already governed by an existing multiplexer, no additional control logic is needed. This elegant interface enables UART communication to function transparently within the single-cycle RISC-V system while preserving the simplicity and modularity of the original datapath.


\chapter{Cocotb Testbench}


\end{document}